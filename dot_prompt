#!/usr/bin/env bash

# @see https://github.com/mathiasbynens/dotfiles/blob/13e29f408fc360360b4468aef2c318dff287c7d2/.bash_prompt#L8-L12
if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
  export TERM='gnome-256color';
elif infocmp xterm-256color >/dev/null 2>&1; then
  export TERM='xterm-256color';
fi;

# @see https://github.com/mathiasbynens/dotfiles/blob/13e29f408fc360360b4468aef2c318dff287c7d2/.bash_prompt#L14-L58
prompt_git() {
  local s='';
  local branchName='';

  # Check if the current directory is in a Git repository.
  git rev-parse --is-inside-work-tree &>/dev/null || return;

  # Check for what branch we’re on.
  # Get the short symbolic ref. If HEAD isn’t a symbolic ref, get a
  # tracking remote branch or tag. Otherwise, get the
  # short SHA for the latest commit, or give up.
  branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
    git describe --all --exact-match HEAD 2> /dev/null || \
    git rev-parse --short HEAD 2> /dev/null || \
    echo '(unknown)')";

  # Early exit for Chromium & Blink repo, as the dirty check takes too long.
  # Thanks, @paulirish!
  # https://github.com/paulirish/dotfiles/blob/dd33151f/.bash_prompt#L110-L123
  repoUrl="$(git config --get remote.origin.url)";
  if grep -q 'chromium/src.git' <<< "${repoUrl}"; then
    s+='*';
  else
    # Check for uncommitted changes in the index.
    if ! $(git diff --quiet --ignore-submodules --cached); then
      s+='+';
    fi;
    # Check for unstaged changes.
    if ! $(git diff-files --quiet --ignore-submodules --); then
      s+='!';
    fi;
    # Check for untracked files.
    if [ -n "$(git ls-files --others --exclude-standard)" ]; then
      s+='?';
    fi;
    # Check for stashed files.
    if $(git rev-parse --verify refs/stash &>/dev/null); then
      s+='$';
    fi;
  fi;

  [ -n "${s}" ] && s=" [${s}]";

  echo -e "${1}${branchName}${2}${s}";
}

# @see https://github.com/mathiasbynens/dotfiles/blob/13e29f408fc360360b4468aef2c318dff287c7d2/.bash_prompt#L60-L88
if tput setaf 1 &> /dev/null; then
  tput sgr0; # reset colors
  bold=$(tput bold);
  reset=$(tput sgr0);
  # Solarized colors, taken from http://git.io/solarized-colors.
  black=$(tput setaf 0);
  blue=$(tput setaf 33);
  cyan=$(tput setaf 37);
  green=$(tput setaf 64);
  orange=$(tput setaf 166);
  purple=$(tput setaf 125);
  red=$(tput setaf 124);
  violet=$(tput setaf 61);
  white=$(tput setaf 15);
  yellow=$(tput setaf 136);
else
  bold='';
  reset="\e[00m";
  black="\e[1;30m";
  blue="\e[1;34m";
  cyan="\e[1;36m";
  green="\e[1;32m";
  orange="\e[1;33m";
  purple="\e[1;35m";
  red="\e[1;31m";
  violet="\e[1;35m";
  white="\e[1;37m";
  yellow="\e[1;33m";
fi;

# @see https://github.com/mathiasbynens/dotfiles/blob/13e29f408fc360360b4468aef2c318dff287c7d2/.bash_prompt#L90-L102
# Highlight the user name when logged in as root.
if [[ "${USER}" == "root" ]]; then
  userColor="${red}";
else
  userColor="${orange}";
fi;

# Highlight the hostname when connected via SSH.
if [[ "${SSH_TTY}" ]]; then
  hostColor="${bold}${red}";
else
  hostColor="${yellow}";
fi;

# @see https://redandblack.io/blog/2020/bash-prompt-with-updating-time/
DIRECTORY="\w"
HOSTNAME="\h"
NEWLINE="\n"
PRINTING_OFF="\["
PRINTING_ON="\]"
PROMPT_COLOUR="${yellow}"
PS1_PROMPT="\$"
PS2_PROMPT="→"
RESTORE_CURSOR_POSITION="\e[u"
SAVE_CURSOR_POSITION="\e[s"
TIMESTAMP="\D{%FT%T%z (%Z)}"
TIMESTAMP_PLACEHOLDER="--:--"
USERNAME="\u"

ansi_escape() {
  echo "${PRINTING_OFF}${1}${PRINTING_ON}"
}

# This is shared between PS0 and PS1 -- PS0 needs it to correctly reproduce
# PS1's user-input line.
COMMAND_PROMPT_ELEMENTS=(
  "${NEWLINE}"
  "$(ansi_escape "${white}")" "${PS1_PROMPT} "
  "$(ansi_escape "${reset}")"
)

# @see https://redandblack.io/blog/2020/bash-prompt-with-updating-time/
#
# @note PS0 was added in Bash 4.4 (http://stromberg.dnsalias.org/~strombrg/PS0-prompt/).
#   macOS ships with Bash 3.x because newer versions are under GPL v3
#   (https://www.reddit.com/r/bash/comments/393oqv/why_is_the_version_of_bash_included_in_os_x_so_old/)
#   To make PS0 work, you'll need to install a more recent version of Bash
#   (https://www.cyberciti.biz/faq/change-default-shell-to-bash-on-macos-catalina/).
move_cursor_to_start_of_ps1() {
  local lines
  command_rows="$(history 1 | wc -l)"
  if [ "${command_rows}" -gt 1 ]; then
    lines="${command_rows}"
  else
    command="$(history 1 | sed -E 's:^.+\*::')"
    command_length="${#command}"
    ps1_prompt_length="${#PS1_PROMPT}"
    (( total_length = command_length + ps1_prompt_length ))
    (( lines = total_length / COLUMNS + 1 ))
  fi
  # The timestamp placeholder may not be on the first line of PS1, and PS1
  # may be more than 1-2 lines. This uses sed to strips out everything before
  # the placeholder, then gets the number of lines with wc. Note that if
  # $TIMESTAMP_PLACEHOLDER contains '/' this sed command will fail -- in that
  # case the '/'s in the command will need to be replaced with a different
  #  delimiter. (I often use ':', e.g. "sed 's:xx:yy:'", but
  # $TIMESTAMP_PLACEHOLDER contains ':'.)
  # * The timestamp placeholder may not be on the first line of `$PS1`, and
  #   `$PS1` may be more than 1-2 lines. This uses `sed` to strip out
  #   everything before the placeholder to ensure the line count is correct.
  #   Note that if `$TIMESTAMP_PLACEHOLDER` contains `/` this `sed` command
  #   will fail -- in that case the `/`s in the command will need to be
  #   replaced with a different delimiter. (I often use `:`, e.g.
  #   `"sed 's:xx:yy:'"`, but `$TIMESTAMP_PLACEHOLDER` contains `:`.)
  # * `grep`'s `--fixed-strings` searches for "\n" sequences, rather than
  #   literal newlines.
  # * `grep`'s `--only-matching` prints just the "\n" sequences, so it's easier
  #   to be sure `wc -l` is counting correctly.
  ps1_lines="$(echo "${PS1}" | sed -E "s/.+${TIMESTAMP_PLACEHOLDER}//" | grep --fixed-strings "\n" --only-matching | wc -l)"
  (( vertical_movement = lines + ps1_lines ))
  tput cuu "$vertical_movement"
}
PS0_ELEMENTS=(
  "${SAVE_CURSOR_POSITION}"
  "\$(move_cursor_to_start_of_ps1)"
  "${PROMPT_COLOUR}" "${TIMESTAMP}" "${reset}"
  "${RESTORE_CURSOR_POSITION}"
  "${NEWLINE}"
  $(IFS=; echo "${COMMAND_PROMPT_ELEMENTS[*]}")
  # Push output to the line below the end of PS1 & the user input.
  "${NEWLINE}"
)
PS0=$(IFS=; echo "${PS0_ELEMENTS[*]}")
export PS0

git_branch_prefix=(
  "$(ansi_escape "${white}")" "on" "$(ansi_escape "${violet}")"
)
git_status_prefix=(
  "$(ansi_escape "${blue}")"
)
PS1_ELEMENTS=(
  # set current directory's `dirname` (`\W`) as terminal title
  "$(ansi_escape "\033]0;\W\007")"
  # visually separate prompt from output of previous command
  "${NEWLINE}"
  # timestamp placeholder on its own line
  "$(ansi_escape "${PROMPT_COLOUR}")" "${TIMESTAMP_PLACEHOLDER}"
  "$(ansi_escape "${reset}")"
  "${NEWLINE}"
  "$(ansi_escape "${userColor}")" "${USERNAME}"
  "$(ansi_escape "${white}")" " at"
  # hostname
  "$(ansi_escape "${hostColor}")" " ${HOSTNAME}"
  "$(ansi_escape "${white}")" " in"
  "$(ansi_escape "${green}")" " ${DIRECTORY}"
  # git branch and status
  "\$(prompt_git \"${git_branch_prefix[*]}\" \"${git_status_prefix[*]}\")"
  $(IFS=; echo "${COMMAND_PROMPT_ELEMENTS[*]}")
)
PS1=$(IFS=; echo "${PS1_ELEMENTS[*]}")
export PS1

PS2_ELEMENTS=(
  "$(ansi_escape "${PROMPT_COLOUR}")" "${PS2_PROMPT} "
  "$(ansi_escape "${reset}")"
)
PS2=$(IFS=; echo "${PS2_ELEMENTS[*]}")
export PS2

# > [T]his covers a corner case by showing the result of a history substitution
# > command in a subsequent prompt for verification rather than executing it
# > immediately. Without it, history substitution commands like !! and !274
# > cause the time to be written one line too low when the command is run.
shopt -s histverify
